# Why Tupã v0.7.0 is the first language with built-in AI governance

Regulated AI needs determinism, auditability, and domain constraints. v0.7.0 delivers a hybrid engine: general-purpose IR for APIs + a formal ExecutionPlan for pipelines.

## The thesis
You can have performance for general code and formal guarantees for domain orchestration — in one language.

## Effect System
- Tracks IO/Random/Time at compile time.
- Enforces `@deterministic` in pipelines (rejects non-deterministic steps).

## ExecutionPlan
- JSON artifact with `steps`, `constraints`, `metrics`, `metric_plans`, `input_schema`, and optional `seed`.
- Stable contract for runtime, audit, and reproducibility.

## Runtime
- Executes plans with input JSON.
- Validates constraints, emits pass/fail and metric values.
- Integrates audit hash and AST fingerprint.
- Deterministic PRNG seeded from plan when needed.

## Developer experience
```bash
cargo run -p tupa-cli -- codegen --format=json examples/pipeline/fraud_complete.tp
cargo run -p tupa-cli -- run --pipeline FraudDetection --input examples/pipeline/tx.json examples/pipeline/fraud_complete.tp
```

## Why governance-native matters
- Pipelines are first-class citizens with guarantees, not ad-hoc scripts.
- Auditable artifacts ready for production and compliance workflows.

## Road to v0.8.0
- Extended TypeSchema (records/fields).
- Sandboxed steps and external registry.
- Eq comparator epsilon configuration and richer metrics APIs.

Tupã v0.7.0 sets the foundation: governance is not an addon. It's part of the language.
